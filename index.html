<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rilevatore di Zanzare</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            width: 100%;
            text-align: center;
        }

        h1 {
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .video-container {
            position: relative;
            display: inline-block;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            margin-bottom: 20px;
        }

        video, canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #495057;
            border: 2px solid #dee2e6;
        }

        .btn-secondary:hover {
            background: #e9ecef;
            transform: translateY(-1px);
        }

        .btn-danger {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .stat-number {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .settings {
            margin-top: 20px;
            text-align: left;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
        }

        .setting-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #495057;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
        }

        .status {
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: 600;
            margin: 10px 0;
        }

        .status.active {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.inactive {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .detection-alert {
            background: linear-gradient(45deg, #ff9a9e, #fecfef);
            color: #721c24;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            font-weight: bold;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        @media (max-width: 600px) {
            .container {
                margin: 10px;
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            button {
                width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü¶ü Rilevatore di Zanzare</h1>
        
        <div class="video-container">
            <video id="video" width="640" height="480" autoplay muted></video>
            <canvas id="canvas" width="640" height="480"></canvas>
        </div>

        <div class="controls">
            <button id="startBtn" class="btn-primary">üìπ Avvia Camera</button>
            <button id="demoBtn" class="btn-secondary">üé¨ Modalit√† Demo</button>
            <button id="detectBtn" class="btn-secondary" disabled>üîç Inizia Rilevamento</button>
            <button id="stopBtn" class="btn-danger" disabled>‚èπÔ∏è Ferma</button>
        </div>

        <div id="status" class="status inactive">Camera non attiva</div>
        
        <div class="info-box" style="background: #e3f2fd; padding: 15px; border-radius: 10px; margin: 20px 0; text-align: left;">
            <h4>üåô Funzionalit√† Notturne:</h4>
            <ul>
                <li><strong>Modalit√† Notturna:</strong> Abilita ottimizzazioni per il buio</li>
                <li><strong>Miglioramento Contrasto:</strong> Aumenta la visibilit√†</li>
                <li><strong>Controllo Luminosit√†:</strong> Amplifica segnali deboli</li>
                <li><strong>Persistenza:</strong> Filtra falsi positivi con rilevamenti ripetuti</li>
                <li><strong>Algoritmo Adattivo:</strong> Sensibilit√† automatica per condizioni di scarsa luce</li>
            </ul>
            
            <h4>üì± Per utilizzare su smartphone:</h4>
            <ol>
                <li>Salva questa pagina come file HTML sul tuo dispositivo</li>
                <li>Aprila con il browser del telefono</li>
                <li>Autorizza l'accesso alla camera quando richiesto</li>
                <li>Usa la modalit√† Demo per testare l'algoritmo senza camera</li>
			</ol>
        </div>
        <div id="alert" style="display: none;"></div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-number" id="detectionCount">0</div>
                <div class="stat-label">Rilevamenti Totali</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="currentObjects">0</div>
                <div class="stat-label">Oggetti Attuali</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="avgSize">0</div>
                <div class="stat-label">Dimensione Media (px)</div>
            </div>
        </div>

        <div class="settings">
            <h3>‚öôÔ∏è Impostazioni di Rilevamento</h3>
            
            <div class="setting-group">
                <label for="nightMode">üåô Modalit√† Notturna: <span id="nightModeValue">Disabilitata</span></label>
                <input type="checkbox" id="nightMode" style="transform: scale(1.5); margin: 10px;">
            </div>
            
            <div class="setting-group">
                <label for="sensitivity">Sensibilit√† di Movimento: <span id="sensitivityValue">30</span></label>
                <input type="range" id="sensitivity" min="10" max="100" value="30">
            </div>
            
            <div class="setting-group">
                <label for="contrast">Miglioramento Contrasto: <span id="contrastValue">1.0</span></label>
                <input type="range" id="contrast" min="0.5" max="3.0" step="0.1" value="1.0">
            </div>
            
            <div class="setting-group">
                <label for="brightness">Luminosit√†: <span id="brightnessValue">1.0</span></label>
                <input type="range" id="brightness" min="0.5" max="2.5" step="0.1" value="1.0">
            </div>
            
            <div class="setting-group">
                <label for="minSize">Dimensione Minima Oggetto: <span id="minSizeValue">3</span>px</label>
                <input type="range" id="minSize" min="1" max="20" value="3">
            </div>
            
            <div class="setting-group">
                <label for="maxSize">Dimensione Massima Oggetto: <span id="maxSizeValue">50</span>px</label>
                <input type="range" id="maxSize" min="20" max="200" value="50">
            </div>
            
            <div class="setting-group">
                <label for="persistence">Persistenza Rilevamento: <span id="persistenceValue">3</span> frame</label>
                <input type="range" id="persistence" min="1" max="10" value="3">
            </div>
        </div>
    </div>

    <script>
        class MosquitoDetector {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.stream = null;
                this.isDetecting = false;
                this.previousFrame = null;
                this.detectionCount = 0;
                this.currentDetections = [];
                
                // Parametri di rilevamento
                this.sensitivity = 30;
                this.minSize = 3;
                this.maxSize = 50;
                this.nightMode = false;
                this.contrast = 1.0;
                this.brightness = 1.0;
                this.persistence = 3;
                
                // Buffer per rilevamenti persistenti
                this.detectionHistory = {};
                this.frameCount = 0;
                
                this.initializeElements();
                this.setupEventListeners();
            }

            initializeElements() {
                this.startBtn = document.getElementById('startBtn');
                this.demoBtn = document.getElementById('demoBtn');
                this.detectBtn = document.getElementById('detectBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.status = document.getElementById('status');
                this.alert = document.getElementById('alert');
                
                this.detectionCountEl = document.getElementById('detectionCount');
                this.currentObjectsEl = document.getElementById('currentObjects');
                this.avgSizeEl = document.getElementById('avgSize');
                
                this.sensitivitySlider = document.getElementById('sensitivity');
                this.minSizeSlider = document.getElementById('minSize');
                this.maxSizeSlider = document.getElementById('maxSize');
                this.nightModeToggle = document.getElementById('nightMode');
                this.contrastSlider = document.getElementById('contrast');
                this.brightnessSlider = document.getElementById('brightness');
                this.persistenceSlider = document.getElementById('persistence');
            }

            setupEventListeners() {
                this.startBtn.addEventListener('click', () => this.startCamera());
                this.demoBtn.addEventListener('click', () => this.startDemo());
                this.detectBtn.addEventListener('click', () => this.toggleDetection());
                this.stopBtn.addEventListener('click', () => this.stopCamera());
                
                this.sensitivitySlider.addEventListener('input', (e) => {
                    this.sensitivity = parseInt(e.target.value);
                    document.getElementById('sensitivityValue').textContent = this.sensitivity;
                });
                
                this.minSizeSlider.addEventListener('input', (e) => {
                    this.minSize = parseInt(e.target.value);
                    document.getElementById('minSizeValue').textContent = this.minSize;
                });
                
                this.maxSizeSlider.addEventListener('input', (e) => {
                    this.maxSize = parseInt(e.target.value);
                    document.getElementById('maxSizeValue').textContent = this.maxSize;
                });
                
                this.nightModeToggle.addEventListener('change', (e) => {
                    this.nightMode = e.target.checked;
                    document.getElementById('nightModeValue').textContent = this.nightMode ? 'Abilitata' : 'Disabilitata';
                    
                    // Regola automaticamente i parametri per la modalit√† notturna
                    if (this.nightMode) {
                        this.contrastSlider.value = 2.0;
                        this.brightnessSlider.value = 1.5;
                        this.sensitivitySlider.value = 15;
                        this.persistenceSlider.value = 5;
                    } else {
                        this.contrastSlider.value = 1.0;
                        this.brightnessSlider.value = 1.0;
                        this.sensitivitySlider.value = 30;
                        this.persistenceSlider.value = 3;
                    }
                    
                    // Aggiorna i valori
                    this.contrast = parseFloat(this.contrastSlider.value);
                    this.brightness = parseFloat(this.brightnessSlider.value);
                    this.sensitivity = parseInt(this.sensitivitySlider.value);
                    this.persistence = parseInt(this.persistenceSlider.value);
                    
                    // Aggiorna le etichette
                    document.getElementById('contrastValue').textContent = this.contrast.toFixed(1);
                    document.getElementById('brightnessValue').textContent = this.brightness.toFixed(1);
                    document.getElementById('sensitivityValue').textContent = this.sensitivity;
                    document.getElementById('persistenceValue').textContent = this.persistence;
                });
                
                this.contrastSlider.addEventListener('input', (e) => {
                    this.contrast = parseFloat(e.target.value);
                    document.getElementById('contrastValue').textContent = this.contrast.toFixed(1);
                });
                
                this.brightnessSlider.addEventListener('input', (e) => {
                    this.brightness = parseFloat(e.target.value);
                    document.getElementById('brightnessValue').textContent = this.brightness.toFixed(1);
                });
                
                this.persistenceSlider.addEventListener('input', (e) => {
                    this.persistence = parseInt(e.target.value);
                    document.getElementById('persistenceValue').textContent = this.persistence;
                });
            }

            async startCamera() {
                try {
                    // Verifica se il browser supporta getUserMedia
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('Browser non supporta l\'accesso alla camera');
                    }

                    this.updateStatus('üîÑ Richiesta accesso alla camera...', 'active');
                    
                    // Prima prova con configurazione semplice
                    let constraints = {
                        video: true,
                        audio: false
                    };
                    
                    try {
                        this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    } catch (basicError) {
                        console.log('Tentativo base fallito, provo con impostazioni specifiche...');
                        
                        // Seconda prova con configurazioni pi√π specifiche
                        constraints = {
                            video: { 
                                facingMode: { ideal: 'environment' },
                                width: { min: 320, ideal: 640, max: 1280 },
                                height: { min: 240, ideal: 480, max: 720 }
                            },
                            audio: false
                        };
                        
                        this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    }
                    
                    this.video.srcObject = this.stream;
                    await this.video.play();
                    
                    this.startBtn.disabled = true;
                    this.demoBtn.disabled = true;
                    this.detectBtn.disabled = false;
                    this.stopBtn.disabled = false;
                    
                    this.updateStatus('‚úÖ Camera attiva - Pronto per il rilevamento', 'active');
                    
                } catch (error) {
                    console.error('Errore accesso camera:', error);
                    
                    let errorMessage = '‚ö†Ô∏è ';
                    if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                        errorMessage += 'Permesso camera negato. Controlla le impostazioni del browser.';
                    } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                        errorMessage += 'Nessuna camera trovata sul dispositivo.';
                    } else if (error.name === 'NotSupportedError') {
                        errorMessage += 'Camera non supportata su questo browser.';
                    } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                        errorMessage += 'Camera in uso da un\'altra app.';
                    } else {
                        errorMessage += `Errore camera: ${error.message}`;
                    }
                    
                    errorMessage += ' Usa la modalit√† Demo per testare.';
                    this.updateStatus(errorMessage, 'inactive');
                    
                    // Mostra suggerimenti per risolvere il problema
                    this.showCameraTroubleshooting();
                }
            }

            startDemo() {
                // Simula un video con movimento casuale per testare l'algoritmo
                this.isDemoMode = true;
                this.demoParticles = [];
                
                // Crea particelle simulate che si muovono come zanzare
                for (let i = 0; i < 3; i++) {
                    this.demoParticles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        size: 2 + Math.random() * 3
                    });
                }
                
                this.startBtn.disabled = true;
                this.demoBtn.disabled = true;
                this.detectBtn.disabled = false;
                this.stopBtn.disabled = false;
                
                this.updateStatus('üé¨ Modalit√† Demo attiva - Pronto per il rilevamento', 'active');
                this.drawDemoFrame();
            }

            drawDemoFrame() {
                if (!this.isDemoMode) return;
                
                // Pulisci il canvas con un background
                this.ctx.fillStyle = '#f0f0f0';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Disegna un pattern di sfondo per simulare una stanza
                this.ctx.strokeStyle = '#ddd';
                this.ctx.lineWidth = 1;
                for (let i = 0; i < this.canvas.width; i += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i, 0);
                    this.ctx.lineTo(i, this.canvas.height);
                    this.ctx.stroke();
                }
                for (let i = 0; i < this.canvas.height; i += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, i);
                    this.ctx.lineTo(this.canvas.width, i);
                    this.ctx.stroke();
                }
                
                // Aggiorna e disegna le particelle simulate
                this.demoParticles.forEach(particle => {
                    // Movimento casuale con rimbalzi
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    if (particle.x <= 0 || particle.x >= this.canvas.width) particle.vx *= -1;
                    if (particle.y <= 0 || particle.y >= this.canvas.height) particle.vy *= -1;
                    
                    // Aggiusta posizione se fuori dai bordi
                    particle.x = Math.max(0, Math.min(this.canvas.width, particle.x));
                    particle.y = Math.max(0, Math.min(this.canvas.height, particle.y));
                    
                    // Cambiamento casuale di direzione
                    if (Math.random() < 0.02) {
                        particle.vx += (Math.random() - 0.5) * 0.5;
                        particle.vy += (Math.random() - 0.5) * 0.5;
                    }
                    
                    // Disegna la particella
                    this.ctx.fillStyle = '#333';
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, 2 * Math.PI);
                    this.ctx.fill();
                });
                
                // Continua l'animazione
                setTimeout(() => this.drawDemoFrame(), 50);
            }

            toggleDetection() {
                if (!this.isDetecting) {
                    this.startDetection();
                } else {
                    this.stopDetection();
                }
            }

            startDetection() {
                this.isDetecting = true;
                this.detectBtn.textContent = '‚è∏Ô∏è Pausa Rilevamento';
                this.detectBtn.className = 'btn-danger';
                this.updateStatus('üîç Rilevamento attivo...', 'active');
                this.detectLoop();
            }

            stopDetection() {
                this.isDetecting = false;
                this.detectBtn.textContent = 'üîç Inizia Rilevamento';
                this.detectBtn.className = 'btn-secondary';
                this.updateStatus('Camera attiva - Rilevamento in pausa', 'active');
                this.clearCanvas();
            }

            detectLoop() {
                if (!this.isDetecting) return;
                
                this.processFrame();
                requestAnimationFrame(() => this.detectLoop());
            }

            processFrame() {
                this.frameCount++;
                let currentFrame;
                
                if (this.isDemoMode) {
                    // Usa il canvas demo come sorgente
                    currentFrame = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                } else {
                    // Usa il video della camera
                    if (this.video.readyState !== 4) return;
                    this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                    currentFrame = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                }
                
                // Applica miglioramenti per condizioni di scarsa illuminazione
                if (this.nightMode || this.contrast !== 1.0 || this.brightness !== 1.0) {
                    currentFrame = this.enhanceImageForLowLight(currentFrame);
                }
                
                if (this.previousFrame) {
                    const detections = this.detectMovement(currentFrame, this.previousFrame);
                    
                    // Filtra i rilevamenti usando la persistenza
                    const filteredDetections = this.filterDetectionsWithPersistence(detections);
                    
                    this.currentDetections = filteredDetections;
                    this.drawDetections(filteredDetections);
                    this.updateStats(filteredDetections);
                    
                    /*if (filteredDetections.length > 0) {
                        this.showAlert(`üö® Rilevate ${filteredDetections.length} possibili zanzare!`);
                    } else {
                        this.hideAlert();
                    }*/
                }
                
                this.previousFrame = currentFrame;
            }

            enhanceImageForLowLight(imageData) {
                const data = imageData.data;
                const enhanced = new ImageData(data.slice(), imageData.width, imageData.height);
                
                for (let i = 0; i < enhanced.data.length; i += 4) {
                    let r = enhanced.data[i];
                    let g = enhanced.data[i + 1];
                    let b = enhanced.data[i + 2];
                    
                    // Applica correzione luminosit√†
                    r *= this.brightness;
                    g *= this.brightness;
                    b *= this.brightness;
                    
                    // Applica correzione contrasto
                    r = ((r / 255 - 0.5) * this.contrast + 0.5) * 255;
                    g = ((g / 255 - 0.5) * this.contrast + 0.5) * 255;
                    b = ((b / 255 - 0.5) * this.contrast + 0.5) * 255;
                    
                    // Applica riduzione rumore se in modalit√† notturna
                    if (this.nightMode) {
                        const avg = (r + g + b) / 3;
                        const factor = 0.3; // Fattore di riduzione rumore
                        r = r * (1 - factor) + avg * factor;
                        g = g * (1 - factor) + avg * factor;
                        b = b * (1 - factor) + avg * factor;
                    }
                    
                    // Assicura che i valori siano nel range corretto
                    enhanced.data[i] = Math.max(0, Math.min(255, r));
                    enhanced.data[i + 1] = Math.max(0, Math.min(255, g));
                    enhanced.data[i + 2] = Math.max(0, Math.min(255, b));
                }
                
                return enhanced;
            }

            filterDetectionsWithPersistence(detections) {
                const filtered = [];
                const currentTime = this.frameCount;
                
                // Aggiorna la cronologia dei rilevamenti
                detections.forEach(detection => {
                    const key = `${Math.round(detection.x / 10)}_${Math.round(detection.y / 10)}`;
                    
                    if (!this.detectionHistory[key]) {
                        this.detectionHistory[key] = {
                            count: 1,
                            lastSeen: currentTime,
                            firstSeen: currentTime,
                            totalX: detection.x,
                            totalY: detection.y,
                            totalSize: detection.size
                        };
                    } else {
                        this.detectionHistory[key].count++;
                        this.detectionHistory[key].lastSeen = currentTime;
                        this.detectionHistory[key].totalX += detection.x;
                        this.detectionHistory[key].totalY += detection.y;
                        this.detectionHistory[key].totalSize += detection.size;
                    }
                });
                
                // Pulisci i rilevamenti vecchi
                Object.keys(this.detectionHistory).forEach(key => {
                    if (currentTime - this.detectionHistory[key].lastSeen > 30) {
                        delete this.detectionHistory[key];
                    }
                });
                
                // Filtra solo i rilevamenti persistenti
                Object.values(this.detectionHistory).forEach(history => {
                    if (history.count >= this.persistence && 
                        currentTime - history.lastSeen <= 2) {
                        filtered.push({
                            x: history.totalX / history.count,
                            y: history.totalY / history.count,
                            size: history.totalSize / history.count,
                            confidence: Math.min(history.count / (this.persistence * 3), 1),
                            persistence: history.count
                        });
                    }
                });
                
                return filtered;
            }

            detectMovement(current, previous) {
                const detections = [];
                const threshold = this.nightMode ? this.sensitivity * 0.7 : this.sensitivity; // Soglia pi√π bassa al buio
                const data1 = current.data;
                const data2 = previous.data;
                
                // Crea una mappa di differenze con algoritmo migliorato per il buio
                const diffMap = [];
                for (let i = 0; i < data1.length; i += 4) {
                    let diff;
                    
                    if (this.nightMode) {
                        // Algoritmo pi√π sensibile per condizioni di scarsa illuminazione
                        const r_diff = Math.abs(data1[i] - data2[i]);
                        const g_diff = Math.abs(data1[i + 1] - data2[i + 1]);
                        const b_diff = Math.abs(data1[i + 2] - data2[i + 2]);
                        
                        // Usa il canale con maggiore differenza
                        diff = Math.max(r_diff, g_diff, b_diff);
                        
                        // Amplifica le differenze piccole al buio
                        if (diff > 5 && diff < 20) {
                            diff *= 2;
                        }
                    } else {
                        // Algoritmo standard
                        diff = Math.abs(data1[i] - data2[i]) + 
                               Math.abs(data1[i + 1] - data2[i + 1]) + 
                               Math.abs(data1[i + 2] - data2[i + 2]);
                    }
                    
                    diffMap.push(diff > threshold ? 1 : 0);
                }
                
                // Trova regioni connesse con algoritmo migliorato
                const visited = new Array(diffMap.length).fill(false);
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const index = y * width + x;
                        if (diffMap[index] && !visited[index]) {
                            const region = this.floodFill(diffMap, visited, x, y, width, height);
                            
                            // Criteri di filtro pi√π flessibili per il buio
                            const minSizeAdjusted = this.nightMode ? this.minSize * 0.7 : this.minSize;
                            const maxSizeAdjusted = this.nightMode ? this.maxSize * 1.3 : this.maxSize;
                            
                            if (region.size >= minSizeAdjusted && region.size <= maxSizeAdjusted) {
                                // Calcola la confidenza basata su dimensione e compattezza
                                const compactness = this.calculateCompactness(region);
                                const sizeScore = 1 - Math.abs(region.size - (minSizeAdjusted + maxSizeAdjusted) / 2) / maxSizeAdjusted;
                                
                                detections.push({
                                    x: region.centerX,
                                    y: region.centerY,
                                    size: region.size,
                                    confidence: (compactness * 0.4 + sizeScore * 0.6) * (this.nightMode ? 1.2 : 1),
                                    compactness: compactness
                                });
                            }
                        }
                    }
                }
                
                return detections;
            }

            calculateCompactness(region) {
                if (region.size <= 1) return 0;
                
                // Calcola il perimetro approssimativo
                let perimeter = 0;
                const pointSet = new Set(region.points.map(p => `${p.x},${p.y}`));
                
                region.points.forEach(point => {
                    const neighbors = [
                        {x: point.x + 1, y: point.y},
                        {x: point.x - 1, y: point.y},
                        {x: point.x, y: point.y + 1},
                        {x: point.x, y: point.y - 1}
                    ];
                    
                    neighbors.forEach(neighbor => {
                        if (!pointSet.has(`${neighbor.x},${neighbor.y}`)) {
                            perimeter++;
                        }
                    });
                });
                
                // Compattezza = Area / Perimetro^2 (normalizzata)
                return region.size / (perimeter * perimeter) * 100;
            }

            floodFill(diffMap, visited, startX, startY, width, height) {
                const stack = [{x: startX, y: startY}];
                const region = {
                    points: [],
                    size: 0,
                    centerX: 0,
                    centerY: 0
                };
                
                while (stack.length > 0) {
                    const {x, y} = stack.pop();
                    const index = y * width + x;
                    
                    if (x < 0 || x >= width || y < 0 || y >= height || 
                        visited[index] || !diffMap[index]) {
                        continue;
                    }
                    
                    visited[index] = true;
                    region.points.push({x, y});
                    region.size++;
                    
                    // Aggiungi i vicini
                    stack.push(
                        {x: x + 1, y: y},
                        {x: x - 1, y: y},
                        {x: x, y: y + 1},
                        {x: x, y: y - 1}
                    );
                }
                
                // Calcola il centro
                if (region.size > 0) {
                    region.centerX = region.points.reduce((sum, p) => sum + p.x, 0) / region.size;
                    region.centerY = region.points.reduce((sum, p) => sum + p.y, 0) / region.size;
                }
                
                return region;
            }

            drawDetections(detections) {
                // In modalit√† demo, non ridisegnare il background
                if (!this.isDemoMode) {
                    this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                }
                
                detections.forEach((detection, index) => {
                    const radius = Math.max(8, Math.sqrt(detection.size) * 1.5);
                    const opacity = 0.4 + (detection.confidence * 0.6);
                    
                    // Colore basato sulla confidenza e persistenza
                    let color = 'rgba(255, 0, 0';
                    if (detection.persistence && detection.persistence >= this.persistence * 2) {
                        color = 'rgba(255, 165, 0'; // Arancione per alta persistenza
                    }
                    if (detection.confidence > 0.8) {
                        color = 'rgba(220, 20, 60'; // Rosso intenso per alta confidenza
                    }
                    
                    // Cerchio di rilevamento con effetto pulsante se alta confidenza
                    this.ctx.beginPath();
                    const pulseRadius = detection.confidence > 0.7 ? 
                        radius + Math.sin(this.frameCount * 0.2) * 3 : radius;
                    this.ctx.arc(detection.x, detection.y, pulseRadius, 0, 2 * Math.PI);
                    this.ctx.strokeStyle = `${color}, ${opacity})`;
                    this.ctx.lineWidth = detection.confidence > 0.6 ? 3 : 2;
                    this.ctx.stroke();
                    
                    // Cerchio interno per zanzare persistenti
                    if (detection.persistence && detection.persistence >= this.persistence) {
                        this.ctx.beginPath();
                        this.ctx.arc(detection.x, detection.y, radius * 0.4, 0, 2 * Math.PI);
                        this.ctx.fillStyle = `${color}, ${opacity * 0.7})`;
                        this.ctx.fill();
                    }
                    
                    // Punto centrale
                    this.ctx.beginPath();
                    this.ctx.arc(detection.x, detection.y, 2, 0, 2 * Math.PI);
                    this.ctx.fillStyle = `${color}, ${Math.min(opacity + 0.3, 1)})`;
                    this.ctx.fill();
                    
                    // Etichetta migliorata
                    const label = `${detection.persistence ? 'P' : ''}Zanzara ${index + 1}`;
                    const confidence = Math.round(detection.confidence * 100);
                    
                    // Background dell'etichetta
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(detection.x + 12, detection.y - 20, 80, 25);
                    
                    // Testo dell'etichetta
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = 'bold 11px Arial';
                    this.ctx.fillText(label, detection.x + 15, detection.y - 8);
                    this.ctx.font = '9px Arial';
                    this.ctx.fillText(`${confidence}%`, detection.x + 15, detection.y + 2);
                    
                    // Indicatore di movimento (freccia)
                    if (detection.persistence && detection.persistence > 3) {
                        this.drawMovementIndicator(detection.x, detection.y - radius - 10, color, opacity);
                    }
                });
            }

            drawMovementIndicator(x, y, color, opacity) {
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                this.ctx.lineTo(x - 4, y - 8);
                this.ctx.lineTo(x + 4, y - 8);
                this.ctx.closePath();
                this.ctx.fillStyle = `${color}, ${opacity})`;
                this.ctx.fill();
            }

            updateStats(detections) {
                this.detectionCount += detections.length;
                this.detectionCountEl.textContent = this.detectionCount;
                this.currentObjectsEl.textContent = detections.length;
                
                if (detections.length > 0) {
                    const avgSize = detections.reduce((sum, d) => sum + d.size, 0) / detections.length;
                    this.avgSizeEl.textContent = Math.round(avgSize);
                } else {
                    this.avgSizeEl.textContent = '0';
                }
            }

            showAlert(message) {
                this.alert.textContent = message;
                this.alert.className = 'detection-alert';
                this.alert.style.display = 'block';
            }

            hideAlert() {
                this.alert.style.display = 'none';
            }

            clearCanvas() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            updateStatus(message, type) {
                this.status.textContent = message;
                this.status.className = `status ${type}`;
            }

            stopCamera() {
                this.isDetecting = false;
                this.isDemoMode = false;
                
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
                
                this.video.srcObject = null;
                this.clearCanvas();
                
                this.startBtn.disabled = false;
                this.demoBtn.disabled = false;
                this.detectBtn.disabled = true;
                this.stopBtn.disabled = true;
                this.detectBtn.textContent = 'üîç Inizia Rilevamento';
                this.detectBtn.className = 'btn-secondary';
                
                this.updateStatus('Camera non attiva', 'inactive');
                this.hideAlert();
            }
        }

        // Inizializza l'applicazione
        document.addEventListener('DOMContentLoaded', () => {
            new MosquitoDetector();
        });
    </script>
</body>
</html>
